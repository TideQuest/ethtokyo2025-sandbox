"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSignDataForClaim = createSignDataForClaim;
exports.assertValidClaimSignatures = assertValidClaimSignatures;
exports.getIdentifierFromClaimInfo = getIdentifierFromClaimInfo;
exports.canonicalStringify = canonicalStringify;
exports.hashProviderParams = hashProviderParams;
const tls_1 = require("@reclaimprotocol/tls");
const canonicalize_1 = __importDefault(require("canonicalize"));
const ethers_1 = require("ethers");
const config_1 = require("../config");
const api_1 = require("../proto/api");
const signatures_1 = require("../utils/signatures");
/**
 * Creates the standard string to sign for a claim.
 * This data is what the attestor will sign when it successfully
 * verifies a claim.
 */
function createSignDataForClaim(data) {
    const identifier = 'identifier' in data
        ? data.identifier
        : getIdentifierFromClaimInfo(data);
    const lines = [
        identifier,
        // we lowercase the owner to ensure that the
        // ETH addresses always serialize the same way
        data.owner.toLowerCase(),
        data.timestampS.toString(),
        data.epoch.toString(),
    ];
    return lines.join('\n');
}
/**
 * Verify the claim tunnel response from a attestor.
 *
 * If you'd only like to verify the claim signature, you can
 * optionally only pass "claim" & "signatures.claimSignature"
 * to this function.
 *
 * The successful run of this function means that the claim
 * is valid, and the attestor that signed the claim is valid.
 */
async function assertValidClaimSignatures({ signatures, ...res }, metadata = config_1.DEFAULT_METADATA) {
    if (!signatures) {
        throw new Error('No signatures provided');
    }
    const { resultSignature, claimSignature, attestorAddress } = signatures;
    const { verify } = signatures_1.SIGNATURES[metadata.signatureType];
    if (signatures === null || signatures === void 0 ? void 0 : signatures.resultSignature) {
        const resBytes = api_1.ClaimTunnelResponse.encode(api_1.ClaimTunnelResponse.create(res)).finish();
        const verified = await verify(resBytes, resultSignature, attestorAddress);
        if (!verified) {
            throw new Error('Invalid result signature');
        }
    }
    // claim wasn't generated -- i.e. the transcript
    // did not contain the necessary data
    if (!res.claim) {
        return;
    }
    const signData = createSignDataForClaim(res.claim);
    const verifiedClaim = await verify((0, tls_1.strToUint8Array)(signData), claimSignature, attestorAddress);
    if (!verifiedClaim) {
        throw new Error('Invalid claim signature');
    }
}
/**
 * Generates a unique identifier for given claim info
 * @param info
 * @returns
 */
function getIdentifierFromClaimInfo(info) {
    var _a;
    //re-canonicalize context if it's not empty
    if (((_a = info.context) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        try {
            const ctx = JSON.parse(info.context);
            info.context = canonicalStringify(ctx);
        }
        catch (e) {
            throw new Error('unable to parse non-empty context. Must be JSON');
        }
    }
    const str = `${info.provider}\n${info.parameters}\n${info.context || ''}`;
    //console.log('Identifier: ' + btoa(str))
    return ethers_1.utils.keccak256((0, tls_1.strToUint8Array)(str)).toLowerCase();
}
/**
 * Canonically stringifies an object, so that the same object will always
 * produce the same string despite the order of keys
 */
function canonicalStringify(params) {
    if (!params) {
        return '';
    }
    return (0, canonicalize_1.default)(params) || '';
}
function hashProviderParams(params) {
    const filteredParams = {
        url: params.url,
        method: params.method,
        body: params.body,
        responseMatches: params.responseMatches,
        responseRedactions: params.responseRedactions
    };
    const serializedParams = canonicalStringify(filteredParams);
    return ethers_1.utils.keccak256((0, tls_1.strToUint8Array)(serializedParams)).toLowerCase();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhaW1zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL2NsYWltcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQWFBLHdEQWNDO0FBWUQsZ0VBK0NDO0FBT0QsZ0VBaUJDO0FBTUQsZ0RBTUM7QUFFRCxnREFhQztBQXpJRCw4Q0FBc0Q7QUFDdEQsZ0VBQXVDO0FBQ3ZDLG1DQUE4QjtBQUM5Qix1Q0FBNkM7QUFDN0MsdUNBQW1EO0FBRW5ELHFEQUFpRDtBQUVqRDs7OztHQUlHO0FBQ0gsU0FBZ0Isc0JBQXNCLENBQUMsSUFBdUI7SUFDN0QsTUFBTSxVQUFVLEdBQUcsWUFBWSxJQUFJLElBQUk7UUFDdEMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVO1FBQ2pCLENBQUMsQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUNuQyxNQUFNLEtBQUssR0FBRztRQUNiLFVBQVU7UUFDViw0Q0FBNEM7UUFDNUMsOENBQThDO1FBQzlDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFO1FBQ3hCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFO1FBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFO0tBQ3JCLENBQUE7SUFFRCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDeEIsQ0FBQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNJLEtBQUssVUFBVSwwQkFBMEIsQ0FDL0MsRUFDQyxVQUFVLEVBQ1YsR0FBRyxHQUFHLEVBQ3dCLEVBQy9CLFFBQVEsR0FBRyx5QkFBZ0I7SUFFM0IsSUFBRyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQTtJQUMxQyxDQUFDO0lBRUQsTUFBTSxFQUNMLGVBQWUsRUFDZixjQUFjLEVBQ2QsZUFBZSxFQUNmLEdBQUcsVUFBVSxDQUFBO0lBRWQsTUFBTSxFQUFFLE1BQU0s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