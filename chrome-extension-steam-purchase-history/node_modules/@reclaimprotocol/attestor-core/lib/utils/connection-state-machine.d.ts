/**
 * Connection state machine for managing atomic state transitions.
 * Prevents race conditions in connection state management.
 */
export declare enum ConnectionState {
    CONNECTING = "connecting",
    CONNECTED = "connected",
    CLOSING = "closing",
    CLOSED = "closed"
}
type StateChangeListener = (oldState: ConnectionState, newState: ConnectionState) => void;
export declare class ConnectionStateMachine {
    private currentState;
    private listeners;
    private transitionLock;
    constructor(initialState?: ConnectionState);
    /**
     * Get current state.
     */
    getState(): ConnectionState;
    /**
     * Check if the connection is in any of the specified states.
     */
    isInState(...states: ConnectionState[]): boolean;
    /**
     * Register a state change listener.
     */
    onStateChange(listener: StateChangeListener): () => void;
    /**
     * Attempt to transition from allowed states to a new state.
     * @param fromStates Allowed states to transition from
     * @param toState Target state
     * @param action Optional action to execute during transition
     * @returns Promise that resolves to true if transition succeeded
     */
    transition(fromStates: ConnectionState | ConnectionState[], toState: ConnectionState, action?: () => Promise<void>): Promise<boolean>;
    /**
     * Force a state change without checking allowed transitions.
     * Use with caution - mainly for error recovery.
     */
    forceState(newState: ConnectionState): Promise<void>;
}
export {};
