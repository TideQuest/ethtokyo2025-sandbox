"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preparePacketsForReveal = preparePacketsForReveal;
const tls_1 = require("@reclaimprotocol/tls");
const api_1 = require("../proto/api");
const zk_1 = require("../utils/zk");
/**
 * Prepares the packets for reveal to the server
 * according to the specified reveal type
 */
async function preparePacketsForReveal(tlsTranscript, reveals, { onZkProgress, ...opts }) {
    const transcript = [];
    const proofGenerator = await (0, zk_1.makeZkProofGenerator)(opts);
    let zkPacketsDone = 0;
    await Promise.all(tlsTranscript.map(async ({ message, sender }) => {
        const msg = {
            sender: sender === 'client'
                ? api_1.TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT
                : api_1.TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER,
            message: message.data,
            reveal: undefined
        };
        transcript.push(msg);
        const reveal = reveals.get(message);
        if (!reveal || message.type === 'plaintext') {
            return;
        }
        switch (reveal === null || reveal === void 0 ? void 0 : reveal.type) {
            case 'complete':
                msg.reveal = {
                    directReveal: {
                        key: await tls_1.crypto.exportKey(message.encKey),
                        iv: message.fixedIv,
                        recordNumber: message.recordNumber,
                    },
                };
                break;
            case 'zk':
                // the redacted section can be smaller than the actual
                // plaintext encrypted, in case of TLS1.3 as it has a
                // content type suffix
                reveal.redactedPlaintext = (0, tls_1.concatenateUint8Arrays)([
                    reveal.redactedPlaintext,
                    message.plaintext.slice(reveal.redactedPlaintext.length)
                ]);
                await proofGenerator.addPacketToProve(message, reveal, proofs => (msg.reveal = { zkReveal: { proofs } }));
                break;
            default:
                // no reveal
                break;
        }
    }));
    const zkPacketsTotal = proofGenerator.getTotalChunksToProve();
    onZkProgress === null || onZkProgress === void 0 ? void 0 : onZkProgress(zkPacketsDone, zkPacketsTotal);
    await proofGenerator.generateProofs(() => {
        zkPacketsDone += 1;
        onZkProgress === null || onZkProgress === void 0 ? void 0 : onZkProgress(zkPacketsDone, zkPacketsTotal);
    });
    return transcript;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlcGFyZS1wYWNrZXRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL3ByZXBhcmUtcGFja2V0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQXFCQSwwREFtRUM7QUF4RkQsOENBQW9HO0FBQ3BHLHVDQUdzQjtBQUV0QixxQ0FBbUQ7QUFXbkQ7OztHQUdHO0FBQ0ksS0FBSyxVQUFVLHVCQUF1QixDQUM1QyxhQUE0QyxFQUM1QyxPQUFpRCxFQUNqRCxFQUFFLFlBQVksRUFBRSxHQUFHLElBQUksRUFBK0I7SUFFdEQsTUFBTSxVQUFVLEdBQXdCLEVBQUUsQ0FBQTtJQUMxQyxNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUEseUJBQW9CLEVBQUMsSUFBSSxDQUFDLENBQUE7SUFFdkQsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFBO0lBRXJCLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFO1FBQ2hFLE1BQU0sR0FBRyxHQUFzQjtZQUM5QixNQUFNLEVBQUUsTUFBTSxLQUFLLFFBQVE7Z0JBQzFCLENBQUMsQ0FBQyxpQ0FBMkIsQ0FBQyxxQ0FBcUM7Z0JBQ25FLENBQUMsQ0FBQyxpQ0FBMkIsQ0FBQyxxQ0FBcUM7WUFDcEUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJO1lBQ3JCLE1BQU0sRUFBRSxTQUFTO1NBQ2pCLENBQUE7UUFDRCxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBRXBCLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDbkMsSUFBRyxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBRSxDQUFDO1lBQzVDLE9BQU07UUFDUCxDQUFDO1FBRUQsUUFBUSxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsSUFBSSxFQUFFLENBQUM7WUFDdkIsS0FBSyxVQUFVO2dCQUNkLEdBQUcsQ0FBQyxNQUFNLEdBQUc7b0JBQ1osWUFBWSxFQUFFO3dCQUNiLEdBQUcsRUFBRSxNQUFNLFlBQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQzt3QkFDM0MsRUFBRSxFQUFFLE9BQU8sQ0FBQyxPQUFPO3dCQUNuQixZQUFZLEVBQUUsT0FBTyxDQUFDLFlBQVk7cUJBQ2xDO2lCQUNELENBQUE7Z0JBQ0QsTUFBSztZQUNOLEtBQUssSUFBSTtnQkFDUixzREFBc0Q7Z0JBQ3RELHFEQUFxRDtnQkFDckQsc0JBQXNCO2dCQUN0QixNQUFNLENBQUMsaUJBQWlCLEdBQUcsSUFBQSw0QkFBc0IsRUFBQztvQkFDakQsTUFBTSxDQUFDLGlCQUFpQjtvQkFDeEIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQztpQkFDeEQsQ0FBQyxDQUFBO2dCQUVGLE1BQU0sY0FBYyxDQUFDLGdCQUFnQixDQUNwQyxPQUFPLEVBQ1AsTUFBTSxFQUNOLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLEVBQUUsUUFBUSxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUNqRCxDQUFBO2dCQUNELE1BQUs7WUFDTjtnQkFDQyxZQUFZO2dCQUNaLE1BQUs7UUFDTixDQUFDO0lBQ0YsQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUVILE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFBO0lBQzdELFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRyxhQUFhLEVBQUUsY0FBYyxDQUFDLENBQUE7SUFFN0MsTUFBTSxjQUFjLENBQUMsY0FBYyxDQUNsQyxHQUFHLEVBQUU7UUFDSixhQUFhLElBQUksQ0FBQyxDQUFBO1FBQ2xCLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRyxhQUFhLEVBQUUsY0FBYyxDQUFDLENBQUE7SUFDOUMsQ0FBQyxDQUNELENBQUE7SUFFRCxPQUFPLFVBQVUsQ0FBQTtBQUNsQixDQUFDIn0=