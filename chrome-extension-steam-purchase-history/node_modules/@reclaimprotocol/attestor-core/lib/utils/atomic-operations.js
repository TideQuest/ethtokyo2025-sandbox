"use strict";
/**
 * Atomic operations utility for preventing race conditions.
 * Provides mutex-like locks using Promise-based mutual exclusion.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AtomicOperations = void 0;
class AtomicOperations {
    /**
     * Execute a function with a named lock to prevent concurrent execution.
     * @param lockName Unique identifier for the lock
     * @param fn Function to execute atomically
     * @returns Promise that resolves with the function's return value
     */
    static async withLock(lockName, fn) {
        // Wait for any existing lock to complete
        const existingLock = this.locks.get(lockName);
        if (existingLock) {
            await existingLock.catch(() => {
                // Ignore errors from previous lock holders
            });
        }
        // Create a new lock
        let resolve;
        let reject;
        const lockPromise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        this.locks.set(lockName, lockPromise);
        try {
            // Execute the function
            const result = await fn();
            resolve();
            return result;
        }
        catch (error) {
            reject(error);
            throw error;
        }
        finally {
            // Clean up the lock if we're still the current holder
            if (this.locks.get(lockName) === lockPromise) {
                this.locks.delete(lockName);
            }
        }
    }
    /**
     * Check if a lock is currently held.
     * @param lockName Name of the lock to check
     * @returns True if the lock is currently held
     */
    static isLocked(lockName) {
        return this.locks.has(lockName);
    }
    /**
     * Clear all locks (for testing/cleanup).
     */
    static clearAllLocks() {
        this.locks.clear();
    }
}
exports.AtomicOperations = AtomicOperations;
AtomicOperations.locks = new Map();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXRvbWljLW9wZXJhdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvYXRvbWljLW9wZXJhdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7O0FBRUgsTUFBYSxnQkFBZ0I7SUFHNUI7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBSSxRQUFnQixFQUFFLEVBQW9CO1FBQzlELHlDQUF5QztRQUN6QyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUM3QyxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQ2xCLE1BQU0sWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUU7Z0JBQzdCLDJDQUEyQztZQUM1QyxDQUFDLENBQUMsQ0FBQTtRQUNILENBQUM7UUFFRCxvQkFBb0I7UUFDcEIsSUFBSSxPQUFtQixDQUFBO1FBQ3ZCLElBQUksTUFBNEIsQ0FBQTtRQUNoQyxNQUFNLFdBQVcsR0FBRyxJQUFJLE9BQU8sQ0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUNsRCxPQUFPLEdBQUcsR0FBRyxDQUFBO1lBQ2IsTUFBTSxHQUFHLEdBQUcsQ0FBQTtRQUNiLENBQUMsQ0FBQyxDQUFBO1FBRUYsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFBO1FBRXJDLElBQUksQ0FBQztZQUNKLHVCQUF1QjtZQUN2QixNQUFNLE1BQU0sR0FBRyxNQUFNLEVBQUUsRUFBRSxDQUFBO1lBQ3pCLE9BQVEsRUFBRSxDQUFBO1lBQ1YsT0FBTyxNQUFNLENBQUE7UUFDZCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNoQixNQUFPLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDZCxNQUFNLEtBQUssQ0FBQTtRQUNaLENBQUM7Z0JBQVMsQ0FBQztZQUNWLHNEQUFzRDtZQUN0RCxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxLQUFLLFdBQVcsRUFBRSxDQUFDO2dCQUM5QyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUM1QixDQUFDO1FBQ0YsQ0FBQztJQUNGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFFBQVEsQ0FBQyxRQUFnQjtRQUMvQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0lBQ2hDLENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxhQUFhO1FBQ25CLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUE7SUFDbkIsQ0FBQzs7QUExREYsNENBMkRDO0FBMURlLHNCQUFLLEdBQUcsSUFBSSxHQUFHLEVBQXlCLENBQUEifQ==