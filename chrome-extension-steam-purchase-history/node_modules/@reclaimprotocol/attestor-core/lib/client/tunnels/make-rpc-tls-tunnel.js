"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRpcTlsTunnel = void 0;
const tls_1 = require("@reclaimprotocol/tls");
const make_rpc_tcp_tunnel_1 = require("../../client/tunnels/make-rpc-tcp-tunnel");
const config_1 = require("../../config");
const utils_1 = require("../../utils");
/**
 * Makes a TLS tunnel that connects to the server via RPC protocol
 */
const makeRpcTlsTunnel = async ({ onMessage, onClose, tlsOpts, request, connect, logger }) => {
    const transcript = [];
    const tunnelId = request.id || (0, utils_1.generateTunnelId)();
    let tunnel;
    let client;
    let handshakeResolve;
    let handshakeReject;
    const waitForHandshake = new Promise((resolve, reject) => {
        handshakeResolve = resolve;
        handshakeReject = reject;
    });
    const tls = (0, tls_1.makeTLSClient)({
        host: request.host,
        ...tlsOpts,
        logger,
        onHandshake() {
            handshakeResolve === null || handshakeResolve === void 0 ? void 0 : handshakeResolve();
        },
        onApplicationData(plaintext) {
            return onMessage === null || onMessage === void 0 ? void 0 : onMessage(plaintext);
        },
        onTlsEnd: onConnectionClose,
        async write(packet, ctx) {
            const message = (0, tls_1.concatenateUint8Arrays)([
                packet.header,
                packet.content
            ]);
            transcript.push({
                sender: 'client',
                message: { ...ctx, data: message }
            });
            if (!tunnel) {
                // sends the packet as the initial message
                // to the plaintext tunnel. Prevents another
                // round trip to the server as we send the packet
                // in the same message as the tunnel creation.
                const createTunnelReqId = (0, utils_1.generateRpcMessageId)();
                client = await connect([
                    {
                        id: createTunnelReqId,
                        createTunnelRequest: {
                            host: request.host || '',
                            port: request.port || config_1.DEFAULT_HTTPS_PORT,
                            geoLocation: request.geoLocation || '',
                            id: tunnelId
                        },
                    },
                    { tunnelMessage: { tunnelId, message } }
                ]);
                try {
                    await makeTunnel();
                    // wait for tunnel to be successfully created
                    await client.waitForResponse(createTunnelReqId);
                }
                catch (err) {
                    onConnectionClose(err);
                }
                return;
            }
            return tunnel.write(message);
        },
        onRead(packet, ctx) {
            transcript.push({
                sender: 'server',
                message: {
                    ...ctx,
                    data: (0, tls_1.concatenateUint8Arrays)([
                        packet.header,
                        // the TLS package sends us the decrypted
                        // content, so we need to get the orginal
                        // ciphertext received from the server
                        // as that's part of the true transcript.
                        ctx.type === 'ciphertext'
                            ? ctx.ciphertext
                            : packet.content
                    ])
                }
            });
        },
    });
    await tls.startHandshake();
    // wait for handshake completion
    await waitForHandshake;
    handshakeResolve = handshakeReject = undefined;
    return {
        transcript,
        tls,
        write(data) {
            return tls.write(data);
        },
        async close(err) {
            onConnectionClose(err);
            try {
                await tunnel.close(err);
            }
            catch (err) {
                logger === null || logger === void 0 ? void 0 : logger.error({ err }, 'err in close tunnel');
            }
        },
    };
    function onConnectionClose(err) {
        onClose === null || onClose === void 0 ? void 0 : onClose(err);
        // once the TLS connection is closed, we no longer
        // want to send `onClose` events back to the caller
        // of this function.
        onClose = undefined;
        handshakeReject === null || handshakeReject === void 0 ? void 0 : handshakeReject(err);
    }
    async function makeTunnel() {
        tunnel = await (0, make_rpc_tcp_tunnel_1.makeRpcTcpTunnel)({
            tunnelId,
            client: client,
            onMessage(data) {
                tls.handleReceivedBytes(data);
            },
            onClose(err) {
                void tls.end(err);
            },
        });
        logger === null || logger === void 0 ? void 0 : logger.debug('plaintext tunnel created');
        return tunnel;
    }
};
exports.makeRpcTlsTunnel = makeRpcTlsTunnel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFrZS1ycGMtdGxzLXR1bm5lbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jbGllbnQvdHVubmVscy9tYWtlLXJwYy10bHMtdHVubmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDhDQUFrRztBQUNsRyxnRkFBeUU7QUFDekUsdUNBQStDO0FBRy9DLHFDQUFrRTtBQXFCbEU7O0dBRUc7QUFDSSxNQUFNLGdCQUFnQixHQUF1RCxLQUFLLEVBQUMsRUFDekYsU0FBUyxFQUFFLE9BQU8sRUFDbEIsT0FBTyxFQUFFLE9BQU8sRUFDaEIsT0FBTyxFQUFFLE1BQU0sRUFDZixFQUFFLEVBQUU7SUFDSixNQUFNLFVBQVUsR0FBc0MsRUFBRSxDQUFBO0lBQ3hELE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxFQUFFLElBQUksSUFBQSx3QkFBZ0IsR0FBRSxDQUFBO0lBQ2pELElBQUksTUFBa0IsQ0FBQTtJQUN0QixJQUFJLE1BQW1DLENBQUE7SUFFdkMsSUFBSSxnQkFBcUQsQ0FBQTtJQUN6RCxJQUFJLGVBQW9ELENBQUE7SUFDeEQsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLE9BQU8sQ0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUM5RCxnQkFBZ0IsR0FBRyxPQUFPLENBQUE7UUFDMUIsZUFBZSxHQUFHLE1BQU0sQ0FBQTtJQUN6QixDQUFDLENBQUMsQ0FBQTtJQUVGLE1BQU0sR0FBRyxHQUFHLElBQUEsbUJBQWEsRUFBQztRQUN6QixJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUs7UUFDbkIsR0FBRyxPQUFPO1FBQ1YsTUFBTTtRQUNOLFdBQVc7WUFDVixnQkFBZ0IsYUFBaEIsZ0JBQWdCLHVCQUFoQixnQkFBZ0IsRUFBSSxDQUFBO1FBQ3JCLENBQUM7UUFDRCxpQkFBaUIsQ0FBQyxTQUFTO1lBQzFCLE9BQU8sU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFHLFNBQVMsQ0FBQyxDQUFBO1FBQzlC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