import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export declare const protobufPackage = "reclaim_attestor";
export declare enum TranscriptMessageSenderType {
    TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN = 0,
    TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT = 1,
    TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER = 2,
    UNRECOGNIZED = -1
}
export declare function transcriptMessageSenderTypeFromJSON(object: any): TranscriptMessageSenderType;
export declare function transcriptMessageSenderTypeToJSON(object: TranscriptMessageSenderType): string;
export declare enum ServiceSignatureType {
    SERVICE_SIGNATURE_TYPE_UNKNOWN = 0,
    /**
     * SERVICE_SIGNATURE_TYPE_ETH - ETH keys & signature
     * keys: secp256k1
     * signature: ethereum flavor of ECDSA (https://goethereumbook.org/signature-generate/)
     */
    SERVICE_SIGNATURE_TYPE_ETH = 1,
    UNRECOGNIZED = -1
}
export declare function serviceSignatureTypeFromJSON(object: any): ServiceSignatureType;
export declare function serviceSignatureTypeToJSON(object: ServiceSignatureType): string;
export declare enum AttestorVersion {
    ATTESTOR_VERSION_UNKNOWN = 0,
    ATTESTOR_VERSION_1_0_0 = 1,
    ATTESTOR_VERSION_1_1_0 = 2,
    ATTESTOR_VERSION_2_0_0 = 3,
    ATTESTOR_VERSION_2_0_1 = 4,
    UNRECOGNIZED = -1
}
export declare function attestorVersionFromJSON(object: any): AttestorVersion;
export declare function attestorVersionToJSON(object: AttestorVersion): string;
export declare enum ErrorCode {
    /**
     * ERROR_NO_ERROR - 0 should be treated as the absence of an error
     * should be used when gracefully closing the connection
     */
    ERROR_NO_ERROR = 0,
    /**
     * ERROR_INTERNAL - internal error in the attestor -- all "Error/TypeError"
     * messages are mapped to this
     */
    ERROR_INTERNAL = 1,
    /** ERROR_BAD_REQUEST - bad request from the client */
    ERROR_BAD_REQUEST = 2,
    /** ERROR_NOT_FOUND - the item requested was not found */
    ERROR_NOT_FOUND = 3,
    /** ERROR_PROXY_ERROR - error in the proxy */
    ERROR_PROXY_ERROR = 4,
    /**
     * ERROR_INVALID_CLAIM - claim creation failed -- i.e. the transcript
     * did not result in a valid claim
     */
    ERROR_INVALID_CLAIM = 5,
    /** ERROR_NETWORK_ERROR - any network error */
    ERROR_NETWORK_ERROR = 6,
    /** ERROR_PAYMENT_REFUSED - attestor refused to pay the costs */
    ERROR_PAYMENT_REFUSED = 7,
    /**
     * ERROR_BGP_ANNOUNCEMENT_OVERLAP - BGP announcement overlapped, potentially
     * compromising the claim's authenticity
     */
    ERROR_BGP_ANNOUNCEMENT_OVERLAP = 8,
    /** ERROR_AUTHENTICATION_FAILED - authentication failed */
    ERROR_AUTHENTICATION_FAILED = 9,
    /** ERROR_TIMEOUT - timed out waiting for the server to respond */
    ERROR_TIMEOUT = 10,
    UNRECOGNIZED = -1
}
export declare function errorCodeFromJSON(object: any): ErrorCode;
export declare function errorCodeToJSON(object: ErrorCode): string;
export declare enum ZKProofEngine {
    ZK_ENGINE_SNARKJS = 0,
    ZK_ENGINE_GNARK = 1,
    UNRECOGNIZED = -1
}
export declare function zKProofEngineFromJSON(object: any): ZKProofEngine;
export declare function zKProofEngineToJSON(object: ZKProofEngine): string;
export interface ClaimContext {
    /**
     * Extracted parameters from the TLS transcript
     * by the provider. Any parameters provided by the
     * user will be overwritten
     */
    extractedParameters: {
        [key: string]: string;
    };
    /** Provider hash. TODO: docs */
    providerHash: string;
}
export interface ClaimContext_ExtractedParametersEntry {
    key: string;
    value: string;
}
export interface ProviderClaimData {
    /**
     * Name of the provider to generate the
     * claim using.
     * @example "http"
     */
    provider: string;
    /**
     * Canonically JSON stringified parameters
     * of the claim, as specified by the provider.
     * @example '{"url":"https://example.com","method":"GET"}'
     */
    parameters: string;
    /**
     * Owner of the claim. Must be the public key/address
     * @example "0x1234..."
     */
    owner: string;
    /**
     * Unix timestamp in seconds of the claim being made.
     * Cannot be more than 10 minutes in the past or future
     */
    timestampS: number;
    /**
     * Any additional data you want to store with the claim.
     * Also expected to be a canonical JSON string.
     */
    context: string;
    /**
     * identifier of the claim;
     * Hash of (provider, parameters, context)
     */
    identifier: string;
    /** Legacy V1 Beacon epoch number */
    epoch: number;
}
export interface ProviderClaimInfo {
    provider: string;
    parameters: string;
    context: string;
}
export interface ErrorData {
    code: ErrorCode;
    message: string;
    data: string;
}
export interface CreateTunnelRequest {
    /**
     * Assign a unique ID to the client for this tunnel
     * request. This ID will be used to identify the tunnel
     * to later send messages or disconnect the tunnel.
     */
    id: number;
    host: string;
    port: number;
    /**
     * Geo location from which the request will be made.
     * Provide 2 letter ISO country code. Leave empty
     * if you don't want to use geo location.
     *
     * Geo location is implemented using an https proxy
     * eg. US, IN, GB, etc.
     */
    geoLocation: string;
}
export interface DisconnectTunnelRequest {
    id: number;
}
/** empty message */
export interface Empty {
}
export interface TunnelMessage {
    /** ID of the tunnel where this message belongs */
    tunnelId: number;
    message: Uint8Array;
}
export interface TunnelDisconnectEvent {
    tunnelId: number;
    error: ErrorData | undefined;
}
export interface MessageReveal {
    /**
     * direct reveal of the block via the key & IV
     * cipher (aes, chacha) for decryption
     * selected based on `cipherSuite`
     * determined by the server hello packet
     */
    directReveal?: MessageReveal_MessageRevealDirect | undefined;
    /** partially or fully reveal the block via a zk proof */
    zkReveal?: MessageReveal_MessageRevealZk | undefined;
}
export interface MessageReveal_MessageRevealDirect {
    /** key for the block */
    key: Uint8Array;
    /** IV for the block */
    iv: Uint8Array;
    /**
     * used to generate IV in authenticated
     * cipher suites
     */
    recordNumber: number;
}
export interface MessageReveal_MessageRevealZk {
    proofs: MessageReveal_ZKProof[];
}
export interface MessageReveal_ZKProof {
    /**
     * JSON encoded snarkJS proof
     * @deprecated -- use `proofData` instead
     */
    proofJson: string;
    /** the decrypted ciphertext as output by the ZK proof */
    decryptedRedactedCiphertext: Uint8Array;
    /** the plaintext that is fully or partially revealed */
    redactedPlaintext: Uint8Array;
    /**
     * start of this specific block
     * in the redactedPlaintext
     */
    startIdx: number;
    proofData: Uint8Array;
    /**
     * If this block's proof contains an OPRF'd piece of data,
     * then provide the OPRF data here
     */
    toprf: TOPRFPayload | undefined;
}
export interface TOPRFPayload {
    /** Location of the data in the chunk that was masked */
    dataLocation: DataSlice | undefined;
    /** OPRF hash of the data */
    nullifier: Uint8Array;
    responses: TOPRFResponse[];
}
export interface DataSlice {
    fromIndex: number;
    length: number;
}
export interface ClaimRequestData {
    provider: string;
    parameters: string;
    /**
     * Owner of the claim. Must be the public key/address
     * of the signatures
     */
    owner: string;
    /**
     * Timestamp of the claim being made.
     * Cannot be more than 10 minutes in the past
     * or in the future
     */
    timestampS: number;
    context: string;
}
export interface ClaimTunnelRequest {
    /**
     * parameters supplied to establish the tunnel
     * & connect to the end server
     */
    request: CreateTunnelRequest | undefined;
    /** data describing the claim you want to prove */
    data: ClaimRequestData | undefined;
    /**
     * messages from the client & server
     * in the order they were sent/received
     *
     * Attach a proof (if any) to each message
     * to reveal the contents of the message inside
     *
     * The revealed messages should support the proving
     * of the claim as defined in the provider's implementation
     */
    transcript: ClaimTunnelRequest_TranscriptMessage[];
    signatures: ClaimTunnelRequest_Signatures | undefined;
    /** type of ZK engine used. SnarkJS or Gnark */
    zkEngine: ZKProofEngine;
    /** server and client fixed IVs needed for ZK validation */
    fixedServerIV: Uint8Array;
    fixedClientIV: Uint8Array;
}
export interface ClaimTunnelRequest_Signatures {
    /**
     * signature of ClaimTunnelRequest
     * with empty "signatures" field
     */
    requestSignature: Uint8Array;
}
export interface ClaimTunnelRequest_TranscriptMessage {
    /** client or server */
    sender: TranscriptMessageSenderType;
    /** packet data */
    message: Uint8Array;
    reveal: MessageReveal | undefined;
}
export interface ClaimTunnelResponse {
    /** The original request that was made to claim the tunnel */
    request: ClaimTunnelRequest | undefined;
    claim?: ProviderClaimData | undefined;
    error?: ErrorData | undefined;
    signatures: ClaimTunnelResponse_Signatures | undefined;
}
export interface ClaimTunnelResponse_Signatures {
    /** Address of the attestor that has signed the claim */
    attestorAddress: string;
    /**
     * signature of `stringifyProviderClaimData(claim)`,
     * if the claim was successful
     */
    claimSignature: Uint8Array;
    /**
     * signature of the complete ClaimTunnelResponse
     * structure with empty "signatures" field
     */
    resultSignature: Uint8Array;
}
export interface RequestClaimOnAvsRequest {
    /**
     * Chain ID of the chain on which the claim is to be made
     * @example 17000 (holesky)
     */
    chainId: number;
    /** Serialised JSON string of the ClaimRequest struct */
    jsonCreateClaimRequest: string;
    /** ETH signature of the `ClaimRequest` struct */
    requestSignature: Uint8Array;
}
export interface RequestClaimOnAvsResponse {
    txHash: string;
    taskIndex: number;
    jsonTask: string;
}
export interface CompleteClaimOnAvsRequest {
    /**
     * Chain ID of the chain on which the claim is to be made
     * @example 17000 (holesky)
     */
    chainId: number;
    taskIndex: number;
    completedTaskJson: string;
}
export interface CompleteClaimOnAvsResponse {
    txHash: string;
    taskCompletedObjectJson: string;
}
export interface CreateTaskOnMechainRequest {
    timestamp: number;
}
export interface CreateTaskOnMechainResponse {
    taskId: number;
    requiredAttestors: number;
    hosts: string[];
}
export interface AuthenticatedUserData {
    /** Unique identifier for the user */
    id: string;
    createdAt: number;
    /**
     * Unix timestamp in seconds when the user's
     * authentication will expire.
     */
    expiresAt: number;
    /**
     * List of allowed hosts the user is allowed to connect to.
     * Will throw a BAD_REQUEST error if the user tries to connect.
     * Pass an empty list to allow all hosts.
     */
    hostWhitelist: string[];
}
export interface AuthenticationRequest {
    data: AuthenticatedUserData | undefined;
    /** Signature of the `userData` */
    signature: Uint8Array;
}
export interface InitRequest {
    /** Attestor client version */
    clientVersion: AttestorVersion;
    /** Signature type used & expected by the user */
    signatureType: ServiceSignatureType;
    /**
     * Request the attestor to authenticate the user
     * with the given data. If auth fails, will return
     * an AUTHENTICATION_FAILED error.
     */
    auth: AuthenticationRequest | undefined;
}
export interface InitResponse {
    toprfPublicKey: Uint8Array;
}
export interface TOPRFRequest {
    maskedData: Uint8Array;
    engine: ZKProofEngine;
}
export interface TOPRFResponse {
    publicKeyShare: Uint8Array;
    /** OPRF output */
    evaluated: Uint8Array;
    c: Uint8Array;
    r: Uint8Array;
}
export interface RPCMessage {
    /**
     * Per connection unique RPC message ID. Either party sending a
     * duplicate ID will do nothing except confuse the other party.
     *
     * For response messages, the ID should be the same as the request
     * to which it is responding.
     */
    id: number;
    initRequest?: InitRequest | undefined;
    /** Response to the init request. */
    initResponse?: InitResponse | undefined;
    /**
     * Data representing an error in the WebSocket connection.
     * The party sending this message should close the connection
     * immediately after sending this message.
     */
    connectionTerminationAlert?: ErrorData | undefined;
    /**
     * Data representing an error in the attestor's
     * request to the server. This should be sent in case
     * there was an error in processing the request.
     */
    requestError?: ErrorData | undefined;
    /** Create a tunnel to the specified host & port. */
    createTunnelRequest?: CreateTunnelRequest | undefined;
    createTunnelResponse?: Empty | undefined;
    /** Disconnect a tunnel. */
    disconnectTunnelRequest?: DisconnectTunnelRequest | undefined;
    disconnectTunnelResponse?: Empty | undefined;
    /**
     * Message to send through a tunnel. Client can send
     * this message to forward data to the server.
     */
    tunnelMessage?: TunnelMessage | undefined;
    /**
     * Event indicating that a tunnel has been disconnected.
     * The client should not send any more messages through
     * this tunnel.
     */
    tunnelDisconnectEvent?: TunnelDisconnectEvent | undefined;
    /**
     * Using the transcript of a tunnel, make a claim.
     * The tunnel must be disconnected before making a claim.
     */
    claimTunnelRequest?: ClaimTunnelRequest | undefined;
    claimTunnelResponse?: ClaimTunnelResponse | undefined;
    /**
     * Request the attestor to pay for the claim on the chain.
     * The Attestor can choose to reject the request.
     */
    createClaimOnChainRequest?: RequestClaimOnAvsRequest | undefined;
    createClaimOnChainResponse?: RequestClaimOnAvsResponse | undefined;
    /** Submit the work done for the claim on the chain. */
    completeClaimOnChainRequest?: CompleteClaimOnAvsRequest | undefined;
    completeClaimOnChainResponse?: CompleteClaimOnAvsResponse | undefined;
    /** Request to perform thresholded OPRF */
    toprfRequest?: TOPRFRequest | undefined;
    toprfResponse?: TOPRFResponse | undefined;
    /** Request the attestor to create a Task on the ReclaimTask contract. */
    createTaskOnMechainRequest?: CreateTaskOnMechainRequest | undefined;
    createTaskOnMechainResponse?: CreateTaskOnMechainResponse | undefined;
}
export interface RPCMessages {
    messages: RPCMessage[];
}
export declare const ClaimContext: MessageFns<ClaimContext>;
export declare const ClaimContext_ExtractedParametersEntry: MessageFns<ClaimContext_ExtractedParametersEntry>;
export declare const ProviderClaimData: MessageFns<ProviderClaimData>;
export declare const ProviderClaimInfo: MessageFns<ProviderClaimInfo>;
export declare const ErrorData: MessageFns<ErrorData>;
export declare const CreateTunnelRequest: MessageFns<CreateTunnelRequest>;
export declare const DisconnectTunnelRequest: MessageFns<DisconnectTunnelRequest>;
export declare const Empty: MessageFns<Empty>;
export declare const TunnelMessage: MessageFns<TunnelMessage>;
export declare const TunnelDisconnectEvent: MessageFns<TunnelDisconnectEvent>;
export declare const MessageReveal: MessageFns<MessageReveal>;
export declare const MessageReveal_MessageRevealDirect: MessageFns<MessageReveal_MessageRevealDirect>;
export declare const MessageReveal_MessageRevealZk: MessageFns<MessageReveal_MessageRevealZk>;
export declare const MessageReveal_ZKProof: MessageFns<MessageReveal_ZKProof>;
export declare const TOPRFPayload: MessageFns<TOPRFPayload>;
export declare const DataSlice: MessageFns<DataSlice>;
export declare const ClaimRequestData: MessageFns<ClaimRequestData>;
export declare const ClaimTunnelRequest: MessageFns<ClaimTunnelRequest>;
export declare const ClaimTunnelRequest_Signatures: MessageFns<ClaimTunnelRequest_Signatures>;
export declare const ClaimTunnelRequest_TranscriptMessage: MessageFns<ClaimTunnelRequest_TranscriptMessage>;
export declare const ClaimTunnelResponse: MessageFns<ClaimTunnelResponse>;
export declare const ClaimTunnelResponse_Signatures: MessageFns<ClaimTunnelResponse_Signatures>;
export declare const RequestClaimOnAvsRequest: MessageFns<RequestClaimOnAvsRequest>;
export declare const RequestClaimOnAvsResponse: MessageFns<RequestClaimOnAvsResponse>;
export declare const CompleteClaimOnAvsRequest: MessageFns<CompleteClaimOnAvsRequest>;
export declare const CompleteClaimOnAvsResponse: MessageFns<CompleteClaimOnAvsResponse>;
export declare const CreateTaskOnMechainRequest: MessageFns<CreateTaskOnMechainRequest>;
export declare const CreateTaskOnMechainResponse: MessageFns<CreateTaskOnMechainResponse>;
export declare const AuthenticatedUserData: MessageFns<AuthenticatedUserData>;
export declare const AuthenticationRequest: MessageFns<AuthenticationRequest>;
export declare const InitRequest: MessageFns<InitRequest>;
export declare const InitResponse: MessageFns<InitResponse>;
export declare const TOPRFRequest: MessageFns<TOPRFRequest>;
export declare const TOPRFResponse: MessageFns<TOPRFResponse>;
export declare const RPCMessage: MessageFns<RPCMessage>;
export declare const RPCMessages: MessageFns<RPCMessages>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}
export {};
