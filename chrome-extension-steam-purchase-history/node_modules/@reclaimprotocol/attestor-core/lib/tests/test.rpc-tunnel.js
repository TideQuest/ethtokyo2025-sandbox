"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("../client");
const make_rpc_tcp_tunnel_1 = require("../client/tunnels/make-rpc-tcp-tunnel");
const make_rpc_tls_tunnel_1 = require("../client/tunnels/make-rpc-tls-tunnel");
const describe_with_server_1 = require("../tests/describe-with-server");
const utils_1 = require("../tests/utils");
const utils_2 = require("../utils");
(0, describe_with_server_1.describeWithServer)('RPC Tunnel', opts => {
    const { mockHttpsServer, getClientOnServer } = opts;
    let client;
    beforeEach(async () => {
        client = opts.client;
    });
    afterEach(async () => {
        await client.terminateConnection();
    });
    it('should connect to a server via RPC tunnel', async () => {
        // setup tunnel for listening & then
        // connect to it via RPC
        const tunnel = await (0, make_rpc_tcp_tunnel_1.makeRpcTcpTunnel)({ tunnelId: 1, client });
        await client.rpc('createTunnel', {
            id: 1,
            host: 'localhost',
            port: opts.mockhttpsServerPort,
            geoLocation: ''
        });
        const ws = getClientOnServer();
        const socketTunnel = ws === null || ws === void 0 ? void 0 : ws.tunnels[1];
        expect(socketTunnel).toBeTruthy();
        await tunnel.close();
        // check that the server actually closed the tunnel
        // upon our request
        await expect(socketTunnel === null || socketTunnel === void 0 ? void 0 : socketTunnel.write(Buffer.from('hello'))).rejects.toMatchObject({
            code: 'ERR_STREAM_DESTROYED'
        });
    });
    describe('TLS', () => {
        it('should do a TLS handshake via RPC tunnel', async () => {
            const ws = getClientOnServer();
            const tunnel = await (0, make_rpc_tls_tunnel_1.makeRpcTlsTunnel)({
                request: {
                    id: 1,
                    host: 'localhost',
                    port: opts.mockhttpsServerPort,
                },
                tlsOpts: {
                    verifyServerCertificate: false,
                },
                logger: client.logger,
                connect(initMessages) {
                    client.sendMessage(...initMessages)
                        .catch(() => { });
                    // ensure that the client hello message
                    // was sent to the server along the
                    // "createTunnel" request -- that saves
                    // us a round-trip
                    expect(initMessages[1].tunnelMessage)
                        .toBeTruthy();
                    return client;
                },
            });
            expect(ws === null || ws === void 0 ? void 0 : ws.tunnels[1]).toBeTruthy();
            await tunnel.close();
        });
        it('should setup a 0-RTT TLS connection', async () => {
            let client2;
            const tunnel = await (0, make_rpc_tls_tunnel_1.makeRpcTlsTunnel)({
                request: {
                    id: 1,
                    host: 'localhost',
                    port: opts.mockhttpsServerPort,
                },
                tlsOpts: {
                    verifyServerCertificate: false,
                },
                logger: client.logger,
                connect(initMessages) {
                    client2 = new client_1.AttestorClient({
                        url: opts.serverUrl,
                        logger: utils_2.logger.child({ client: 2 }),
                        initMessages
                    });
                    return client2;
                },
            });
            await tunnel.close();
            await (client2 === null || client2 === void 0 ? void 0 : client2.terminateConnection());
        });
        it('should gracefully handle a TLS disconnection alert', async () => {
            let socket;
            mockHttpsServer.server.once('secureConnection', s => {
                socket = s;
            });
            let closeResolve;
            await (0, make_rpc_tls_tunnel_1.makeRpcTlsTunnel)({
                request: {
                    id: 1,
                    host: 'localhost',
                    port: opts.mockhttpsServerPort,
                },
                tlsOpts: {
                    verifyServerCertificate: false,
                },
                logger: client.logger,
                connect(initMessages) {
                    client.sendMessage(...initMessages)
                        .catch(() => { });
                    return client;
                },
                onClose(err) {
                    closeResolve === null || closeResolve === void 0 ? void 0 : closeResolve(err);
                },
            });
            await (0, utils_1.delay)(100);
            expect(socket).toBeTruthy();
            socket === null || socket === void 0 ? void 0 : socket.end();
            const err = await new Promise((resolve) => {
                closeResolve = resolve;
            });
            // since it was a graceful close, there should be no error
            expect(err).toBeUndefined();
        });
        it('should handle TLS handshake errors', async () => {
            await expect((0, make_rpc_tls_tunnel_1.makeRpcTlsTunnel)({
                request: {
                    id: 1,
                    host: 'localhost',
                    port: opts.mockhttpsServerPort,
                },
                tlsOpts: {
                    applicationLayerProtocols: [
                        'invalid-protocol'
                    ]
                },
                logger: client.logger,
                connect(initMessages) {
                    client.sendMessage(...initMessages)
                        .catch(() => { });
                    return client;
                },
            })).rejects.toMatchObject({
                message: /NO_APPLICATION_PROTOCOL/
            });
        });
        it('should handle tunnel creation errors', async () => {
            await expect((0, make_rpc_tls_tunnel_1.makeRpcTlsTunnel)({
                request: {
                    id: 1,
                    host: 'localhost',
                    port: opts.mockhttpsServerPort,
                    // invalid geo location
                    geoLocation: 'XZ'
                },
                tlsOpts: {
                    applicationLayerProtocols: [
                        'invalid-protocol'
                    ]
                },
                logger: client.logger,
                connect(initMessages) {
                    client.sendMessage(...initMessages)
                        .catch(() => { });
                    return client;
                },
            })).rejects.toMatchObject({
                message: /NO_APPLICATION_PROTOCOL/
            });
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5ycGMtdHVubmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Rlc3RzL3Rlc3QucnBjLXR1bm5lbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHVDQUEyQztBQUMzQyxnRkFBeUU7QUFDekUsZ0ZBQXlFO0FBQ3pFLHlFQUFtRTtBQUNuRSwyQ0FBdUM7QUFDdkMscUNBQWtDO0FBR2xDLElBQUEseUNBQWtCLEVBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxFQUFFO0lBRXZDLE1BQU0sRUFBRSxlQUFlLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxJQUFJLENBQUE7SUFFbkQsSUFBSSxNQUFzQixDQUFBO0lBQzFCLFVBQVUsQ0FBQyxLQUFLLElBQUcsRUFBRTtRQUNwQixNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQTtJQUNyQixDQUFDLENBQUMsQ0FBQTtJQUVGLFNBQVMsQ0FBQyxLQUFLLElBQUcsRUFBRTtRQUNuQixNQUFNLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUFBO0lBQ25DLENBQUMsQ0FBQyxDQUFBO0lBRUYsRUFBRSxDQUFDLDJDQUEyQyxFQUFFLEtBQUssSUFBRyxFQUFFO1FBQ3pELG9DQUFvQztRQUNwQyx3QkFBd0I7UUFDeEIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFBLHNDQUFnQixFQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFBO1FBQzlELE1BQU0sTUFBTSxDQUFDLEdBQUcsQ0FDZixjQUFjLEVBQ2Q7WUFDQyxFQUFFLEVBQUUsQ0FBQztZQUNMLElBQUksRUFBRSxXQUFXO1lBQ2pCLElBQUksRUFBRSxJQUFJLENBQUMsbUJBQW1CO1lBQzlCLFdBQVcsRUFBRSxFQUFFO1NBQ2YsQ0FDRCxDQUFBO1FBRUQsTUFBTSxFQUFFLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQTtRQUM5QixNQUFNLFlBQVksR0FBRyxFQUFFLGFBQUYsRUFBRSx1QkFBRixFQUFFLENB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