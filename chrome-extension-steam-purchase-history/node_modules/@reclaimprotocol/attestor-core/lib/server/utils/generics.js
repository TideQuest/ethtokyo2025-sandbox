"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signAsAttestor = signAsAttestor;
exports.getAttestorAddress = getAttestorAddress;
exports.niceParseJsonObject = niceParseJsonObject;
exports.getInitialMessagesFromQuery = getInitialMessagesFromQuery;
const tls_1 = require("@reclaimprotocol/tls");
const api_1 = require("../../proto/api");
const utils_1 = require("../../utils");
const env_1 = require("../../utils/env");
const signatures_1 = require("../../utils/signatures");
const PRIVATE_KEY = (0, env_1.getEnvVariable)('PRIVATE_KEY');
/**
 * Sign message using the PRIVATE_KEY env var.
 */
function signAsAttestor(data, scheme) {
    const { sign } = signatures_1.SIGNATURES[scheme];
    return sign(typeof data === 'string' ? (0, tls_1.strToUint8Array)(data) : data, PRIVATE_KEY);
}
/**
 * Obtain the address on chain, from the PRIVATE_KEY env var.
 */
function getAttestorAddress(scheme) {
    const { getAddress, getPublicKey } = signatures_1.SIGNATURES[scheme];
    const publicKey = getPublicKey(PRIVATE_KEY);
    return getAddress(publicKey);
}
/**
 * Nice parse JSON with a key.
 * If the data is empty, returns an empty object.
 * And if the JSON is invalid, throws a bad request error,
 * with the key in the error message.
 */
function niceParseJsonObject(data, key) {
    if (!data) {
        return {};
    }
    try {
        return JSON.parse(data);
    }
    catch (e) {
        throw utils_1.AttestorError.badRequest(`Invalid JSON in ${key}: ${e.message}`);
    }
}
/**
 * Extract any initial messages sent via the query string,
 * in the `messages` parameter.
 */
function getInitialMessagesFromQuery(req) {
    const url = new URL(req.url, 'http://localhost');
    const messagesB64 = url.searchParams.get('messages');
    if (!(messagesB64 === null || messagesB64 === void 0 ? void 0 : messagesB64.length)) {
        return [];
    }
    const msgsBytes = Buffer.from(messagesB64, 'base64');
    const msgs = api_1.RPCMessages.decode(msgsBytes);
    return msgs.messages;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpY3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc2VydmVyL3V0aWxzL2dlbmVyaWNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBWUEsd0NBU0M7QUFLRCxnREFJQztBQVFELGtEQVlDO0FBTUQsa0VBVUM7QUFsRUQsOENBQXNEO0FBRXRELHVDQUFpRTtBQUNqRSxxQ0FBeUM7QUFDekMsdUNBQThDO0FBQzlDLHFEQUFpRDtBQUVqRCxNQUFNLFdBQVcsR0FBRyxJQUFBLG9CQUFjLEVBQUMsYUFBYSxDQUFFLENBQUE7QUFFbEQ7O0dBRUc7QUFDSCxTQUFnQixjQUFjLENBQzdCLElBQXlCLEVBQ3pCLE1BQTRCO0lBRTVCLE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyx1QkFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQ25DLE9BQU8sSUFBSSxDQUNWLE9BQU8sSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBQSxxQkFBZSxFQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQ3ZELFdBQVcsQ0FDWCxDQUFBO0FBQ0YsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQUMsTUFBNEI7SUFDOUQsTUFBTSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsR0FBRyx1QkFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQ3ZELE1BQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQTtJQUMzQyxPQUFPLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQTtBQUM3QixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FBQyxJQUFZLEVBQUUsR0FBVztJQUM1RCxJQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDVixPQUFPLEVBQUUsQ0FBQTtJQUNWLENBQUM7SUFFRCxJQUFJLENBQUM7UUFDSixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDeEIsQ0FBQztJQUFDLE9BQU0sQ0FBQyxFQUFFLENBQUM7UUFDWCxNQUFNLHFCQUFhLENBQUMsVUFBVSxDQUM3QixtQkFBbUIsR0FBRyxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FDdEMsQ0FBQTtJQUNGLENBQUM7QUFDRixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsMkJBQTJCLENBQUMsR0FBb0I7SUFDL0QsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUksRUFBRSxrQkFBa0IsQ0FBQyxDQUFBO0lBQ2pELE1BQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ3BELElBQUcsQ0FBQyxDQUFBLFdBQVcsYUFBWCxXQUFXLHVCQUFYLFdBQVcsQ0FBRSxNQUFNLENBQUEsRUFBRSxDQUFDO1FBQ3pCLE9BQU8sRUFBRSxDQUFBO0lBQ1YsQ0FBQztJQUVELE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBQ3BELE1BQU0sSUFBSSxHQUFHLGlCQUFXLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFBO0lBQzFDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQTtBQUNyQixDQUFDIn0=