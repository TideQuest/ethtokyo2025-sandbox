"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.claimTunnel = void 0;
const config_1 = require("../../config");
const api_1 = require("../../proto/api");
const apm_1 = require("../../server/utils/apm");
const assert_valid_claim_request_1 = require("../../server/utils/assert-valid-claim-request");
const generics_1 = require("../../server/utils/generics");
const utils_1 = require("../../utils");
const claimTunnel = async (claimRequest, { tx, logger, client }) => {
    var _a, _b, _c, _d;
    const { request, data: { timestampS } = {}, } = claimRequest;
    const tunnel = client.getTunnel(request === null || request === void 0 ? void 0 : request.id);
    try {
        await tunnel.close();
    }
    catch (err) {
        logger.debug({ err }, 'error closing tunnel');
    }
    if (tx) {
        const transcriptBytes = tunnel.transcript.reduce((acc, { message }) => acc + message.length, 0);
        tx === null || tx === void 0 ? void 0 : tx.setLabel('transcriptBytes', transcriptBytes.toString());
    }
    // we throw an error for cases where the attestor cannot prove
    // the user's request is faulty. For eg. if the user sends a
    // "createRequest" that does not match the tunnel's actual
    // create request -- the attestor cannot prove that the user
    // is lying. In such cases, we throw a bad request error.
    // Same goes for matching the transcript.
    if (((_a = tunnel.createRequest) === null || _a === void 0 ? void 0 : _a.host) !== (request === null || request === void 0 ? void 0 : request.host)
        || ((_b = tunnel.createRequest) === null || _b === void 0 ? void 0 : _b.port) !== (request === null || request === void 0 ? void 0 : request.port)
        || ((_c = tunnel.createRequest) === null || _c === void 0 ? void 0 : _c.geoLocation) !== (request === null || request === void 0 ? void 0 : request.geoLocation)) {
        throw utils_1.AttestorError.badRequest('Tunnel request does not match');
    }
    (0, assert_valid_claim_request_1.assertTranscriptsMatch)(claimRequest.transcript, tunnel.transcript);
    const res = api_1.ClaimTunnelResponse.create({ request: claimRequest });
    try {
        const now = (0, utils_1.unixTimestampSeconds)();
        if (Math.floor(timestampS - now) > config_1.MAX_CLAIM_TIMESTAMP_DIFF_S) {
            throw new utils_1.AttestorError('ERROR_INVALID_CLAIM', `Timestamp provided ${timestampS} is too far off. Current time is ${now}`);
        }
        const assertTx = (_d = (0, apm_1.getApm)()) === null || _d === void 0 ? void 0 : _d.startTransaction('assertValidClaimRequest', { childOf: tx });
        try {
            const claim = await (0, assert_valid_claim_request_1.assertValidClaimRequest)(claimRequest, client.metadata, logger);
            res.claim = {
                ...claim,
                identifier: (0, utils_1.getIdentifierFromClaimInfo)(claim),
                // hardcode for compatibility with V1 claims
                epoch: 1
            };
        }
        catch (err) {
            assertTx === null || assertTx === void 0 ? void 0 : assertTx.setOutcome('failure');
            throw err;
        }
        finally {
            assertTx === null || assertTx === void 0 ? void 0 : assertTx.end();
        }
    }
    catch (err) {
        logger.error({ err }, 'invalid claim request');
        const attestorErr = utils_1.AttestorError.fromError(err);
        attestorErr.code = 'ERROR_INVALID_CLAIM';
        res.error = attestorErr.toProto();
    }
    res.signatures = {
        attestorAddress: (0, generics_1.getAttestorAddress)(client.metadata.signatureType),
        claimSignature: res.claim
            ? await (0, generics_1.signAsAttestor)((0, utils_1.createSignDataForClaim)(res.claim), client.metadata.signatureType)
            : new Uint8Array(),
        resultSignature: await (0, generics_1.signAsAttestor)(api_1.ClaimTunnelResponse.encode(res).finish(), client.metadata.signatureType)
    };
    // remove tunnel from client -- to free up our mem
    client.removeTunnel(request.id);
    return res;
};
exports.claimTunnel = claimTunnel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhaW1UdW5uZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc2VydmVyL2hhbmRsZXJzL2NsYWltVHVubmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHVDQUF1RDtBQUN2RCx1Q0FBbUQ7QUFDbkQsOENBQTZDO0FBQzdDLDRGQUE2RztBQUM3Ryx3REFBOEU7QUFFOUUscUNBQW1IO0FBRTVHLE1BQU0sV0FBVyxHQUE4QixLQUFLLEVBQzFELFlBQVksRUFDWixFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQ3JCLEVBQUU7O0lBQ0gsTUFBTSxFQUNMLE9BQU8sRUFDUCxJQUFJLEVBQUUsRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLEdBQ3pCLEdBQUcsWUFBWSxDQUFBO0lBQ2hCLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEVBQUcsQ0FBQyxDQUFBO0lBQzdDLElBQUksQ0FBQztRQUNKLE1BQU0sTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQ3JCLENBQUM7SUFBQyxPQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ2IsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLHNCQUFzQixDQUFDLENBQUE7SUFDOUMsQ0FBQztJQUVELElBQUcsRUFBRSxFQUFFLENBQUM7UUFDUCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FDL0MsQ0FBQyxHQUFHLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQzFDLENBQUMsQ0FDRCxDQUFBO1FBQ0QsRUFBRSxhQUFGLEVBQUUsdUJBQUYsRUFBRSxDQUFFLFFBQVEsQ0FBQyxpQkFBaUIsRUFBRSxlQUFlLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQTtJQUM1RCxDQUFDO0lBRUQsOERBQThEO0lBQzlELDREQUE0RDtJQUM1RCwwREFBMEQ7SUFDMUQsNERBQTREO0lBQzVELHlEQUF5RDtJQUN6RCx5Q0FBeUM7SUFDekMsSUFDQyxDQUFBLE1BQUEsTUFBTSxDQUFDLGFBQWEsMENBQUUsSUFBSSxPQUFLLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxJQUFJLENBQUE7V0FDekMsQ0FBQSxNQUFBLE1BQU0sQ0FBQyxhQUFhLDBDQUFFLElBQUksT0FBSyxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsSUFBSSxDQUFBO1dBQzVDLENBQUEsTUFBQSxNQUFNLENBQUMsYUFBYSwwQ0FBRSxXQUFXLE9BQUssT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFdBQVcsQ0FBQSxFQUM1RCxDQUFDO1FBQ0YsTUFBTSxxQkFBYSxDQUFDLFVBQVUsQ0FBQywrQkFBK0IsQ0FBQyxDQUFBO0lBQ2hFLENBQUM7SUFFRCxJQUFBLG1EQUFzQixFQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBRWxFLE1BQU0sR0FBRyxHQUFHLHlCQUFtQixDQUFDLE1BQU0sQ0FBQyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFBO0lBQ2pFLElBQUksQ0FBQztRQUNKLE1BQU0sR0FBRyxHQUFHLElBQUEsNEJBQW9CLEdBQUUsQ0FBQTtRQUNsQyxJQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVyxHQUFHLEdBQUcsQ0FBQyxHQUFHLG1DQUEwQixFQUFFLENBQUM7WUFDL0QsTUFBTSxJQUFJLHFCQUFhLENBQ3RCLHFCQUFxQixFQUNyQixzQkFBc0IsVUFBVSxvQ0FBb0MsR0FBRyxFQUFFLENBQ3pFLENBQUE7UUFDRixDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQUcsTUFBQSxJQUFBLFlBQU0sR0FBRSwwQ0FDdEIsZ0JBQWdCLENBQUMseUJBQXlCLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQTtRQUUvRCxJQUFJLENBQUM7WUFDSixNQUFNLEtBQUssR0FBRyxNQUFNLElBQUEsb0RBQXVCLEVBQzFDLFlBQVksRUFDWixNQUFNLENBQUMsUUFBUSxFQUNmLE1BQU0sQ0FDTixDQUFBO1lBQ0QsR0FBRyxDQUFDLEtBQUssR0FBRztnQkFDWCxHQUFHLEtBQUs7Z0JBQ1IsVUFBVSxFQUFFLElBQUEsa0NBQTBCLEVBQUMsS0FBSyxDQUFDO2dCQUM3Qyw0Q0FBNEM7Z0JBQzVDLEtBQUssRUFBRSxDQUFDO2FBQ1IsQ0FBQTtRQUNGLENBQUM7UUFBQyxPQUFNLEdBQUcsRUFBRSxDQUFDO1lBQ2IsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQTtZQUMvQixNQUFNLEdBQUcsQ0FBQTtRQUNWLENBQUM7Z0JBQVMsQ0FBQztZQUNWLFFBQVEsYUFBUixRQUFRLHVCQUFSLFFBQVEsQ0FBRSxHQUFHLEVBQUUsQ0FBQTtRQUNoQixDQUFDO0lBQ0YsQ0FBQztJQUFDLE9BQU0sR0FBRyxFQUFFLENBQUM7UUFDYixNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsdUJBQXVCLENBQUMsQ0FBQTtRQUM5QyxNQUFNLFdBQVcsR0FBRyxxQkFBYSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUNoRCxXQUFXLENBQUMsSUFBSSxHQUFHLHFCQUFxQixDQUFBO1FBQ3hDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFBO0lBQ2xDLENBQUM7SUFFRCxHQUFHLENBQUMsVUFBVSxHQUFHO1FBQ2hCLGVBQWUsRUFBRSxJQUFBLDZCQUFrQixFQUNsQyxNQUFNLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FDN0I7UUFDRCxjQUFjLEVBQUUsR0FBRyxDQUFDLEtBQUs7WUFDeEIsQ0FBQyxDQUFDLE1BQU0sSUFBQSx5QkFBYyxFQUNyQixJQUFBLDhCQUFzQixFQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFDakMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQzdCO1lBQ0QsQ0FBQyxDQUFDLElBQUksVUFBVSxFQUFFO1FBQ25CLGVBQWUsRUFBRSxNQUFNLElBQUEseUJBQWMsRUFDcEMseUJBQW1CLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUN4QyxNQUFNLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FDN0I7S0FDRCxDQUFBO0lBRUQsa0RBQWtEO0lBQ2xELE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFBO0lBRS9CLE9BQU8sR0FBRyxDQUFBO0FBQ1gsQ0FBQyxDQUFBO0FBakdZLFFBQUEsV0FBVyxlQWlHdkIifQ==