import { ArraySlice, CompleteTLSPacket, ProviderParams, Transcript } from '../../types';
import { HttpRequest, HttpResponse } from '../../utils';
export type JSONIndex = {
    start: number;
    end: number;
};
type HTTPProviderParams = ProviderParams<'http'>;
/**
 * Returns only first extracted element
 * @param html
 * @param xpathExpression
 * @param contentsOnly
 */
export declare function extractHTMLElement(html: string, xpathExpression: string, contentsOnly: boolean): string;
/**
 * Returns all extracted elements
 * @param html
 * @param xpathExpression
 * @param contentsOnly
 */
export declare function extractHTMLElements(html: string, xpathExpression: string, contentsOnly: boolean): string[];
/**
 * returns a single index of extracted element
 * @param html
 * @param xpathExpression
 * @param contentsOnly
 */
export declare function extractHTMLElementIndex(html: string, xpathExpression: string, contentsOnly: boolean): {
    start: number;
    end: number;
};
/**
 * Returns indexes of all extracted elements
 * @param html
 * @param xpathExpression
 * @param contentsOnly
 */
export declare function extractHTMLElementsIndexes(html: string, xpathExpression: string, contentsOnly: boolean): {
    start: number;
    end: number;
}[];
export declare function extractJSONValueIndex(json: string, jsonPath: string): {
    start: number;
    end: number;
};
export declare function extractJSONValueIndexes(json: string, jsonPath: string): {
    start: number;
    end: number;
}[];
export declare function buildHeaders(input: HTTPProviderParams['headers']): string[];
/**
 * Converts position in HTTP response body to an absolute position in TLS transcript considering chunked encoding
 * @param pos
 * @param bodyStartIdx
 * @param chunks
 */
export declare function convertResponsePosToAbsolutePos(pos: number, bodyStartIdx: number, chunks?: ArraySlice[]): number;
/**
 * If this reveal spans the boundary of two chunks, we'll
 *
 */
export declare function getRedactionsForChunkHeaders(from: number, to: number, chunks?: ArraySlice[]): ArraySlice[];
export declare function parseHttpResponse(buff: Uint8Array): HttpResponse;
export declare function makeRegex(str: string): any;
/**
 * Try to match strings that contain templates like {{param}}
 * against redacted string that has *** instead of that param
 */
export declare function matchRedactedStrings(templateString: Uint8Array, redactedString?: Uint8Array): boolean;
export declare function generateRequstAndResponseFromTranscript(transcript: Transcript<CompleteTLSPacket>, tlsVersion: string): {
    req: HttpRequest;
    res: HttpResponse;
};
export {};
