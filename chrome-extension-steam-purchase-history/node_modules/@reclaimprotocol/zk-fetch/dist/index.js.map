{"version":3,"sources":["../src/index.ts","../src/zkfetch.ts","../src/types.ts","../src/errors.ts","../src/utils.ts","../src/constants.ts"],"sourcesContent":["export * from './zkfetch'\nexport * from './types'","import { createClaimOnAttestor } from \"@reclaimprotocol/attestor-core\";\nimport { HttpMethod, LogType } from \"./types\";\nimport { Options, secretOptions } from \"./interfaces\";\nimport {\n  assertCorrectnessOfOptions,\n  validateURL,\n  sendLogs,\n  validateApplicationIdAndSecret,\n  transformProof,\n} from \"./utils\";\nimport { v4 } from \"uuid\";\nimport P from \"pino\";\nimport { ATTESTOR_NODE_URL } from \"./constants\";\nconst logger = P();\n\nexport class ReclaimClient {\n  applicationId: string;\n  applicationSecret: string;\n  logs?: boolean;\n  sessionId: string;\n  constructor(\n    applicationId: string,\n    applicationSecret: string,\n    logs?: boolean\n  ) {\n    validateApplicationIdAndSecret(applicationId, applicationSecret);\n    this.applicationId = applicationId;\n    this.applicationSecret = applicationSecret;\n    this.sessionId = v4().toString();\n    // if the logs are enabled, set the logger level to info\n    logger.level = logs ? \"info\" : \"silent\";\n    logger.info(\n      `Initializing client with applicationId: ${this.applicationId} and sessionId: ${this.sessionId}`\n    );\n  }\n\n  async zkFetch(\n    url: string,\n    options?: Options,\n    secretOptions?: secretOptions,\n    retries = 1,\n    retryInterval = 1000\n  ) {\n    validateURL(url, \"zkFetch\");\n    if (options !== undefined) {\n      assertCorrectnessOfOptions(options);\n    }\n    await sendLogs({\n      sessionId: this.sessionId,\n      logType: LogType.VERIFICATION_STARTED,\n      applicationId: this.applicationId,\n    });\n\n    let attempt = 0;\n    while (attempt < retries) {\n      try {\n        const claim = await createClaimOnAttestor({\n            name: \"http\",\n            params: {\n              method: (options?.method as HttpMethod) || HttpMethod.GET,\n              url: url,\n              responseMatches: secretOptions?.responseMatches || [\n                {\n                  type: \"regex\",\n                  value: \"(?<data>.*)\",\n                },\n              ],\n              headers: options?.headers,\n              geoLocation: options?.geoLocation,\n              responseRedactions: secretOptions?.responseRedactions || [],\n              body: options?.body || \"\",\n              paramValues: options?.paramValues,\n            },\n            context: options?.context,\n            secretParams: {\n              cookieStr: secretOptions?.cookieStr || \"\",\n              headers: secretOptions?.headers || {},\n              paramValues: secretOptions?.paramValues,\n            },\n            ownerPrivateKey: this.applicationSecret,\n            logger: logger,\n            client: {\n              url: ATTESTOR_NODE_URL,\n            },\n          });\n\n          if (claim.error) {\n            throw new Error(\n              `Failed to create claim on attestor: ${claim.error.message}`\n            );\n          }\n\n          await sendLogs({\n            sessionId: this.sessionId,\n            logType: LogType.PROOF_GENERATED,\n            applicationId: this.applicationId,\n          });\n        return transformProof(claim);\n      } catch (error) {\n        attempt++;\n        if (attempt >= retries) {\n          await sendLogs({\n            sessionId: this.sessionId,\n            logType: LogType.ERROR,\n            applicationId: this.applicationId,\n          });\n          logger.error(error);\n          throw error;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryInterval));\n      }\n    }\n  }\n}\n","\nexport enum HttpMethod {\n    GET = \"GET\",\n    POST = \"POST\",\n    PUT = \"PUT\",\n}\n\nexport enum LogType {\n    VERIFICATION_STARTED = 'VERIFICATION_STARTED',\n    PROOF_GENERATED = 'PROOF_GENERATED',\n    ERROR = 'ERROR',\n    SUCCESS = 'SUCCESS',\n    FAILED = 'FAILED'\n}\n\nexport type ProofRequestOptions = {\n    log?: boolean;\n    sessionId?: string;\n}  \n\nexport type ApplicationId = string;\nexport type ApplicationSecret = string;\nexport type RequestUrl = string;\nexport type ProviderId = string;\nexport type NoReturn = void;\nexport type SessionId = string;","export class InvalidParamError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'InvalidParamError'\n    }\n}\n\nexport class InvalidMethodError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'InvalidMethodError'\n    }\n}\n\nexport class FetchError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'FetchError'\n    }\n}\n\nexport class NetworkError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'NetworkError'\n    }\n}\n\nexport class ApplicationError extends Error {\n    constructor(message?: string) {\n        super(message)\n        this.name = 'ApplicationError'\n    }\n}","import { ApplicationError, InvalidMethodError, InvalidParamError, NetworkError } from './errors';\nimport { ApplicationId, ApplicationSecret, HttpMethod } from './types'\nimport { Options, Proof, SendLogsParams } from './interfaces';\nimport { ethers } from 'ethers';\nimport { APP_BACKEND_URL, LOGS_BACKEND_URL, ATTESTOR_NODE_URL } from './constants';\nimport P from \"pino\";\nimport { ClaimTunnelResponse } from '@reclaimprotocol/attestor-core/lib/proto/api';\nconst logger = P();\n\n/*\n  Options validations utils\n*/\nexport function assertCorrectnessOfOptions(options: Options): void {\n  if (!options.method) {\n    throw new InvalidParamError('Method is required');\n  }\n  if (options.method !== HttpMethod.GET && options.method !== HttpMethod.POST && options.method !== HttpMethod.PUT) {\n    throw new InvalidMethodError(`Method ${options.method} is not allowed`);\n  }\n}\n\n\n/*\n  Params validations utils\n*/\nexport function validateNotNullOrUndefined(input: any, paramName: string, functionName: string) {\n  if (input == null) {\n    throw new InvalidParamError(`${paramName} passed to ${functionName} must not be null or undefined.`);\n  }\n}\n\nexport function validateNonEmptyString(input: string, paramName: string, functionName: string) {\n  if (typeof input !== 'string') {\n    throw new InvalidParamError(`${paramName} passed to ${functionName} must be a string.`);\n  }\n  if (input.trim() === \"\") {\n    throw new InvalidParamError(`${paramName} passed to ${functionName} must be a non-empty string.`);\n  }\n}\n\n\n/* validate applicationId and applicationSecret */\nexport function validateApplicationIdAndSecret(applicationId: ApplicationId, applicationSecret: ApplicationSecret): void {\n  validateNotNullOrUndefined(applicationId, 'applicationId', 'the constructor');\n  validateNonEmptyString(applicationId, 'applicationId', 'the constructor');\n  validateNotNullOrUndefined(applicationSecret, 'applicationSecret', 'the constructor');\n  validateNonEmptyString(applicationSecret, 'applicationSecret', 'the constructor');\n  try {\n    const wallet = new ethers.Wallet(applicationSecret);\n    if (wallet.address !== applicationId) {\n      throw new InvalidParamError(`Invalid applicationId and applicationSecret passed to the constructor.`);\n    }\n  }\n  catch (error) {\n    throw new InvalidParamError(`Invalid applicationId and applicationSecret passed to the constructor.`);\n  }\n}\n\n/* Transform Proof */\nexport function transformProof(proof: ClaimTunnelResponse): Proof {\n  if (!proof || !proof.claim || !proof.signatures) {\n    throw new InvalidParamError(\"Invalid proof object\");\n  }\n  return {\n    claimData: proof.claim,\n    identifier: proof.claim.identifier,\n    signatures: [\n      \"0x\" + Buffer.from(proof.signatures.claimSignature).toString(\"hex\"),\n    ],\n    extractedParameterValues: proof?.claim?.context ? JSON?.parse(proof?.claim?.context)?.extractedParameters : '',\n    witnesses: [\n      {\n        id: proof?.signatures?.attestorAddress,\n        url: ATTESTOR_NODE_URL,\n      },\n    ],\n  };\n}\n\n/* \n  URL validations utils\n*/\nexport function validateURL(url: string, functionName: string): void {\n  validateNotNullOrUndefined(url, 'url', functionName)\n  validateNonEmptyString(url, 'url', functionName)\n  try {\n    new URL(url);\n  } catch (e) {\n    throw new InvalidParamError(`Invalid URL format passed to ${functionName}.`);\n  }\n}\n\n\n// cache for app name to avoid multiple fetches \nconst appNameCache: { [key: string]: string } = {};\n\nexport async function fetchAppById(appId: string): Promise<string> {\n  if (appNameCache[appId]) {\n    return appNameCache[appId];\n  }\n  try {\n    // Deprecated: zkfetch applications migrated to applications\n    // const response = await fetch(`${APP_BACKEND_URL}/api/zkfetch/sdk/${appId}`);\n    const response = await fetch(`${APP_BACKEND_URL}/api/applications/sdk/get-zk-enabled-app/${appId}`);\n    if (response.status === 404) {\n      throw new ApplicationError('Application not found');\n    }\n    if (response.status !== 200) {\n      throw new ApplicationError('Failed to fetch application');\n    }\n\n    const res = await response.json();\n    const appName = res.application.name;\n    appNameCache[appId] = appName; // Update cache\n    return appName;\n  } catch (err) {\n    throw new ApplicationError('Application not found');\n  }\n}\n\n/* \n sendLogs utils\n*/\nexport async function sendLogs(\n  {\n    sessionId,\n    logType,\n    applicationId,\n  }: SendLogsParams\n): Promise<void> {\n  try {\n    const getAppName = await fetchAppById(applicationId);\n    const url = `${LOGS_BACKEND_URL}/api/business-logs/zkfetch`\n    const body = JSON.stringify({\n      sessionId,\n      logType,\n      date: new Date().toISOString(),\n      applicationId: applicationId,\n      applicationName: getAppName,\n    })\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body,\n    })\n\n    if (!response.ok) {\n      logger.error('Failed to send logs')\n    }\n  } catch (error) {\n    if (error instanceof ApplicationError) {\n      throw error\n    }\n    throw new NetworkError('Failed to send logs')\n  }\n}\n","const LOGS_BACKEND_URL = \"https://logs.reclaimprotocol.org\"\nconst APP_BACKEND_URL = \"https://api.reclaimprotocol.org\"\nconst ATTESTOR_NODE_URL = \"wss://attestor.reclaimprotocol.org/ws\"\n\n\nexport { LOGS_BACKEND_URL, APP_BACKEND_URL, ATTESTOR_NODE_URL }"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,2BAAsC;;;ACC/B,IAAK,aAAL,kBAAKA,gBAAL;AACH,EAAAA,YAAA,SAAM;AACN,EAAAA,YAAA,UAAO;AACP,EAAAA,YAAA,SAAM;AAHE,SAAAA;AAAA,GAAA;AAML,IAAK,UAAL,kBAAKC,aAAL;AACH,EAAAA,SAAA,0BAAuB;AACvB,EAAAA,SAAA,qBAAkB;AAClB,EAAAA,SAAA,WAAQ;AACR,EAAAA,SAAA,aAAU;AACV,EAAAA,SAAA,YAAS;AALD,SAAAA;AAAA,GAAA;;;ACPL,IAAM,oBAAN,cAAgC,MAAM;AAAA,EACzC,YAAY,SAAkB;AAC1B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EAChB;AACJ;AAEO,IAAM,qBAAN,cAAiC,MAAM;AAAA,EAC1C,YAAY,SAAkB;AAC1B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EAChB;AACJ;AASO,IAAM,eAAN,cAA2B,MAAM;AAAA,EACpC,YAAY,SAAkB;AAC1B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EAChB;AACJ;AAEO,IAAM,mBAAN,cAA+B,MAAM;AAAA,EACxC,YAAY,SAAkB;AAC1B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EAChB;AACJ;;;AC9BA,oBAAuB;;;ACHvB,IAAM,mBAAmB;AACzB,IAAM,kBAAkB;AACxB,IAAM,oBAAoB;;;ADG1B,kBAAc;AAEd,IAAM,aAAS,YAAAC,SAAE;AAKV,SAAS,2BAA2B,SAAwB;AACjE,MAAI,CAAC,QAAQ,QAAQ;AACnB,UAAM,IAAI,kBAAkB,oBAAoB;AAAA,EAClD;AACA,MAAI,QAAQ,8BAA6B,QAAQ,gCAA8B,QAAQ,4BAA2B;AAChH,UAAM,IAAI,mBAAmB,UAAU,QAAQ,MAAM,iBAAiB;AAAA,EACxE;AACF;AAMO,SAAS,2BAA2B,OAAY,WAAmB,cAAsB;AAC9F,MAAI,SAAS,MAAM;AACjB,UAAM,IAAI,kBAAkB,GAAG,SAAS,cAAc,YAAY,iCAAiC;AAAA,EACrG;AACF;AAEO,SAAS,uBAAuB,OAAe,WAAmB,cAAsB;AAC7F,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,IAAI,kBAAkB,GAAG,SAAS,cAAc,YAAY,oBAAoB;AAAA,EACxF;AACA,MAAI,MAAM,KAAK,MAAM,IAAI;AACvB,UAAM,IAAI,kBAAkB,GAAG,SAAS,cAAc,YAAY,8BAA8B;AAAA,EAClG;AACF;AAIO,SAAS,+BAA+B,eAA8B,mBAA4C;AACvH,6BAA2B,eAAe,iBAAiB,iBAAiB;AAC5E,yBAAuB,eAAe,iBAAiB,iBAAiB;AACxE,6BAA2B,mBAAmB,qBAAqB,iBAAiB;AACpF,yBAAuB,mBAAmB,qBAAqB,iBAAiB;AAChF,MAAI;AACF,UAAM,SAAS,IAAI,qBAAO,OAAO,iBAAiB;AAClD,QAAI,OAAO,YAAY,eAAe;AACpC,YAAM,IAAI,kBAAkB,wEAAwE;AAAA,IACtG;AAAA,EACF,SACO,OAAO;AACZ,UAAM,IAAI,kBAAkB,wEAAwE;AAAA,EACtG;AACF;AAGO,SAAS,eAAe,OAAmC;AAChE,MAAI,CAAC,SAAS,CAAC,MAAM,SAAS,CAAC,MAAM,YAAY;AAC/C,UAAM,IAAI,kBAAkB,sBAAsB;AAAA,EACpD;AACA,SAAO;AAAA,IACL,WAAW,MAAM;AAAA,IACjB,YAAY,MAAM,MAAM;AAAA,IACxB,YAAY;AAAA,MACV,OAAO,OAAO,KAAK,MAAM,WAAW,cAAc,EAAE,SAAS,KAAK;AAAA,IACpE;AAAA,IACA,0BAA0B,OAAO,OAAO,UAAU,MAAM,MAAM,OAAO,OAAO,OAAO,GAAG,sBAAsB;AAAA,IAC5G,WAAW;AAAA,MACT;AAAA,QACE,IAAI,OAAO,YAAY;AAAA,QACvB,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;AAKO,SAAS,YAAY,KAAa,cAA4B;AACnE,6BAA2B,KAAK,OAAO,YAAY;AACnD,yBAAuB,KAAK,OAAO,YAAY;AAC/C,MAAI;AACF,QAAI,IAAI,GAAG;AAAA,EACb,SAAS,GAAG;AACV,UAAM,IAAI,kBAAkB,gCAAgC,YAAY,GAAG;AAAA,EAC7E;AACF;AAIA,IAAM,eAA0C,CAAC;AAEjD,eAAsB,aAAa,OAAgC;AACjE,MAAI,aAAa,KAAK,GAAG;AACvB,WAAO,aAAa,KAAK;AAAA,EAC3B;AACA,MAAI;AAGF,UAAM,WAAW,MAAM,MAAM,GAAG,eAAe,4CAA4C,KAAK,EAAE;AAClG,QAAI,SAAS,WAAW,KAAK;AAC3B,YAAM,IAAI,iBAAiB,uBAAuB;AAAA,IACpD;AACA,QAAI,SAAS,WAAW,KAAK;AAC3B,YAAM,IAAI,iBAAiB,6BAA6B;AAAA,IAC1D;AAEA,UAAM,MAAM,MAAM,SAAS,KAAK;AAChC,UAAM,UAAU,IAAI,YAAY;AAChC,iBAAa,KAAK,IAAI;AACtB,WAAO;AAAA,EACT,SAAS,KAAK;AACZ,UAAM,IAAI,iBAAiB,uBAAuB;AAAA,EACpD;AACF;AAKA,eAAsB,SACpB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,GACe;AACf,MAAI;AACF,UAAM,aAAa,MAAM,aAAa,aAAa;AACnD,UAAM,MAAM,GAAG,gBAAgB;AAC/B,UAAM,OAAO,KAAK,UAAU;AAAA,MAC1B;AAAA,MACA;AAAA,MACA,OAAM,oBAAI,KAAK,GAAE,YAAY;AAAA,MAC7B;AAAA,MACA,iBAAiB;AAAA,IACnB,CAAC;AACD,UAAM,WAAW,MAAM,MAAM,KAAK;AAAA,MAChC,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,MACA;AAAA,IACF,CAAC;AAED,QAAI,CAAC,SAAS,IAAI;AAChB,aAAO,MAAM,qBAAqB;AAAA,IACpC;AAAA,EACF,SAAS,OAAO;AACd,QAAI,iBAAiB,kBAAkB;AACrC,YAAM;AAAA,IACR;AACA,UAAM,IAAI,aAAa,qBAAqB;AAAA,EAC9C;AACF;;;AHnJA,kBAAmB;AACnB,IAAAC,eAAc;AAEd,IAAMC,cAAS,aAAAC,SAAE;AAEV,IAAM,gBAAN,MAAoB;AAAA,EAKzB,YACE,eACA,mBACA,MACA;AACA,mCAA+B,eAAe,iBAAiB;AAC/D,SAAK,gBAAgB;AACrB,SAAK,oBAAoB;AACzB,SAAK,gBAAY,gBAAG,EAAE,SAAS;AAE/B,IAAAD,QAAO,QAAQ,OAAO,SAAS;AAC/B,IAAAA,QAAO;AAAA,MACL,2CAA2C,KAAK,aAAa,mBAAmB,KAAK,SAAS;AAAA,IAChG;AAAA,EACF;AAAA,EAEA,MAAM,QACJ,KACA,SACA,eACA,UAAU,GACV,gBAAgB,KAChB;AACA,gBAAY,KAAK,SAAS;AAC1B,QAAI,YAAY,QAAW;AACzB,iCAA2B,OAAO;AAAA,IACpC;AACA,UAAM,SAAS;AAAA,MACb,WAAW,KAAK;AAAA,MAChB;AAAA,MACA,eAAe,KAAK;AAAA,IACtB,CAAC;AAED,QAAI,UAAU;AACd,WAAO,UAAU,SAAS;AACxB,UAAI;AACF,cAAM,QAAQ,UAAM,4CAAsB;AAAA,UACtC,MAAM;AAAA,UACN,QAAQ;AAAA,YACN,QAAS,SAAS;AAAA,YAClB;AAAA,YACA,iBAAiB,eAAe,mBAAmB;AAAA,cACjD;AAAA,gBACE,MAAM;AAAA,gBACN,OAAO;AAAA,cACT;AAAA,YACF;AAAA,YACA,SAAS,SAAS;AAAA,YAClB,aAAa,SAAS;AAAA,YACtB,oBAAoB,eAAe,sBAAsB,CAAC;AAAA,YAC1D,MAAM,SAAS,QAAQ;AAAA,YACvB,aAAa,SAAS;AAAA,UACxB;AAAA,UACA,SAAS,SAAS;AAAA,UAClB,cAAc;AAAA,YACZ,WAAW,eAAe,aAAa;AAAA,YACvC,SAAS,eAAe,WAAW,CAAC;AAAA,YACpC,aAAa,eAAe;AAAA,UAC9B;AAAA,UACA,iBAAiB,KAAK;AAAA,UACtB,QAAQA;AAAA,UACR,QAAQ;AAAA,YACN,KAAK;AAAA,UACP;AAAA,QACF,CAAC;AAED,YAAI,MAAM,OAAO;AACf,gBAAM,IAAI;AAAA,YACR,uCAAuC,MAAM,MAAM,OAAO;AAAA,UAC5D;AAAA,QACF;AAEA,cAAM,SAAS;AAAA,UACb,WAAW,KAAK;AAAA,UAChB;AAAA,UACA,eAAe,KAAK;AAAA,QACtB,CAAC;AACH,eAAO,eAAe,KAAK;AAAA,MAC7B,SAAS,OAAO;AACd;AACA,YAAI,WAAW,SAAS;AACtB,gBAAM,SAAS;AAAA,YACb,WAAW,KAAK;AAAA,YAChB;AAAA,YACA,eAAe,KAAK;AAAA,UACtB,CAAC;AACD,UAAAA,QAAO,MAAM,KAAK;AAClB,gBAAM;AAAA,QACR;AACA,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,aAAa,CAAC;AAAA,MACnE;AAAA,IACF;AAAA,EACF;AACF;","names":["HttpMethod","LogType","P","import_pino","logger","P"]}