/**
 * Secure PRNG function like 'randomBytes' from '@noble/hashes/utils'
 */
export type RandFn = (bytes: number) => Uint8Array;
export type Hash = {
    (message: Uint8Array): Uint8Array;
    outputLen: number;
    blockLen: number;
    create: () => any;
};
export type Hex = Uint8Array | string;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
export declare function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array;
/**
 * Integer-to-Octet-String Primitive (I2OSP)
 *
 * @param x - The nonnegative integer to be converted.
 * @param xLen - The intended length of the resulting octet string.
 * @returns The corresponding octet string of length xLen.
 */
export declare function I2OSP(x: bigint, xLen: number): Uint8Array;
/**
 * Octet String-to-Integer Primitive (OS2IP)
 *
 * @param X - The octet string to be converted.
 * @returns The corresponding nonnegative integer.
 */
export declare function OS2IP(X: Uint8Array): bigint;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
export declare function pow(num: bigint, power: bigint, modulo: bigint): bigint;
export declare function mod(a: bigint, b: bigint): bigint;
/**
 * Computes the greatest common divisor (GCD) using the Euclidean algorithm.
 * @param a First integer
 * @param b Second integer
 * @returns GCD of a and b (the largest positive integer that divides each of the integers)
 */
export declare function gcd(a: bigint, b: bigint): bigint;
export declare function invert(number: bigint, modulo: bigint): bigint;
/**
 * Calculates the integer square root of a bigint.
 *
 * This function computes the floor of the square root of `n` using a method
 * similar to the Newton-Raphson division. The algorithm starts with a large
 * initial guess and iteratively refines this guess until convergence.
 * The result is the largest integer `b` such that `b * b <= n`.
 *
 * @param n - The non-negative bigint value of which to find the square root.
 * @returns The integer square root of `n`.
 */
export declare function sqrt(n: bigint): bigint;
/**
 * Generates a random bigint with a specific number of bits using a secure PRNG function.
 *
 * @param bits - The desired number of bits in the generated bigint.
 * @param The secure PRNG function to use for generating random bytes.
 * @returns A random bigint with the specified number of bits, in big-endian format.
 */
export declare function randomBits(bits: number, randFn?: RandFn): bigint;
export declare function hexToNumber(hex: string): bigint;
export declare function numberToBytes(n: number | bigint, len?: number): Uint8Array;
export declare function bytesToNumber(bytes: Uint8Array): bigint;
export declare function getFieldBytesLength(fieldOrder: bigint): number;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements
 * @returns byte length of target hash
 */
export declare function getMinHashLength(fieldOrder: bigint): number;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param key hash output from SHA3 or a similar function
 * @param fieldOrder size of subgroup
 * @returns valid private scalar
 */
export declare function mapHashToField(key: Uint8Array, fieldOrder: bigint): Uint8Array;
//# sourceMappingURL=utils.d.ts.map