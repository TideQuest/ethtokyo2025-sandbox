import { randomBytes } from '@noble/hashes/utils';
import { Hash, RandFn } from './utils.js';
export declare const DER: {
    Err: {
        new (m?: string): {
            name: string;
            message: string;
            stack?: string;
        };
    };
    _parseInt(data: Uint8Array): {
        d: bigint;
        l: Uint8Array;
    };
    toSig(hex: string | Uint8Array): {
        r: bigint;
        s: bigint;
    };
    hexFromSig(sig: {
        r: bigint;
        s: bigint;
    }): string;
};
export type DSAParams = {
    p: bigint;
    q: bigint;
    g: bigint;
    hash: Hash;
};
export type DSAProvableParams = DSAParams & {
    domainParameterSeed: Uint8Array;
    counter: number;
    index: number;
};
/**
 * Based on FIPS186-4 (A.1.1.2 Generation of the Probable Primes p and q Using an Approved Hash Function)
 * @param L - The desired length of the prime p (in bits).
 * @param N - The desired length of the prime q (in bits).
 * @param seed - seed: Uint8Array or length in bits (greater or equal to N)
 * @param hash - hash function
 */
declare function genDSAPrimes(L: number, N: number, hash: Hash, seed?: Uint8Array | number, randFn?: RandFn): {
    p: bigint;
    q: bigint;
    domainParameterSeed: Uint8Array;
    counter: number;
    hash: Hash;
};
/**
 * Based on FIPS186-4: A.2.3 Verifiable Canonical Generation of the Generator g
 * @param res - result of genDSAPrimes
 * @param hash - hash algorihm function
 * @param index - index (key separation, for example: index = 1 for digital signatures and with index = 2 for key establishment.)
 */
declare function genDSAGenerator(res: ReturnType<typeof genDSAPrimes>, index: number): bigint;
/**
 *
 * @param L - The desired length of the prime p (in bits).
 * @param N - The desired length of the prime q (in bits).
 * @param hash - hash function
 * @param index - index (key separation, for example: index = 1 for digital signatures and with index = 2 for key establishment.)
 * @param seed - seed: Uint8Array or length in bits (greater or equal to N)
 * @example
 * const params = genDSAParams(3072, 256, sha256, 1); // Generate random params
 * @example
 * const params = genDSAParams(3072, 256, sha256, 1, new Uint8Array([...])); // Generate params from known seed
 */
export declare function genDSAParams(L: number, N: number, hash: Hash, index: number, seed?: Uint8Array | number, randFn?: typeof randomBytes): DSAProvableParams;
type Pred<T> = (v: Uint8Array) => T | undefined;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
export declare function createHmacDrbg<T>(hashLen: number, qByteLen: number, hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array): (seed: Uint8Array, predicate: Pred<T>) => T;
/**
 * Simplified DSA implementation focusing on simplicity and basic functionality.
 * @param params - DSA parameters {p, q, g}
 * @returns DSA key generation, signing, and verification functions
 */
export declare const DSA: (params: DSAParams) => {
    randomPrivateKey(): bigint;
    getPublicKey: (privateKey: bigint) => bigint;
    sign: (privateKey: bigint, message: Uint8Array) => Uint8Array;
    verify: (publicKey: bigint, msg: Uint8Array, sig: Uint8Array) => boolean;
};
export declare const _TEST: {
    genDSAPrimes: typeof genDSAPrimes;
    genDSAGenerator: typeof genDSAGenerator;
};
export {};
//# sourceMappingURL=dsa.d.ts.map