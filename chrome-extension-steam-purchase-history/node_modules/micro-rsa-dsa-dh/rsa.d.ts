import { Hash, RandFn } from './utils.js';
export type VarLenHash = (msg: Uint8Array, opts: {
    dkLen: number;
}) => Uint8Array;
export type HashXOF = VarLenHash & {
    blockLen: number;
    create: (opts: {
        dkLen: number;
    }) => any;
};
export type KEM = {
    encrypt(publicKey: PublicKey, plaintext: Uint8Array): Uint8Array;
    decrypt(privateKey: PrivateKey, ciphertext: Uint8Array): Uint8Array;
};
export type Signer = {
    verify(publicKey: PublicKey, message: Uint8Array, signature: Uint8Array): boolean;
    sign(privateKey: PrivateKey, message: Uint8Array): Uint8Array;
};
/**
 * Generate the RSA primes p and q according to the FIPS 186-5 standard (A.1.3 Generation of Random Primes that are Probably Prime)
 * @param nlen - Bit length of the modulus.
 * @param e - Public exponent. Must be an odd positive integer
 * @param a - Optional parameter for p ≡ a mod 8.
 * @param b - Optional parameter for q ≡ b mod 8.
 */
export declare function IFCPrimes(nlen: number, e?: bigint, a?: number, b?: number, randFn?: RandFn): {
    p: bigint;
    q: bigint;
};
export declare function mgf1(hash: Hash): VarLenHash;
/**
 * Represents an RSA public key.
 * @param n - The RSA modulus, a positive integer which is the product
 *            of two or more primes used in the RSA private key. This value
 *            is public and used in both encryption and signature verification.
 * @param e - The RSA public exponent, a positive integer (usually 65537). Must be coprime to the totient of the modulus.
 */
export type PublicKey = {
    n: bigint;
    e: bigint;
};
/**
 * Represents a simplified RSA private key with basic components.
 * @param n - The RSA modulus, a positive integer which is the product of two primes.
 * @param d - The RSA private exponent, a positive integer used in the decryption algorithm.
 */
export type PrivateKey = {
    n: bigint;
    d: bigint;
};
/**
 * RSA Encryption Primitive (RSAEP)
 *
 * @param publicKey - An object containing RSA public key components.
 * @param m - The message representative.
 * @returns The ciphertext representative.
 */
declare function RSAEP(publicKey: PublicKey, m: bigint): bigint;
/**
 * RSA Decryption Primitive (RSADP)
 *
 * @param privateKey - An object containing RSA private key components.
 * @param c - The ciphertext representative.
 * @returns The message representative.
 * @throws Will throw an error if the ciphertext representative is out of range.
 */
declare function RSADP(privateKey: PrivateKey, c: bigint): bigint;
/**
 * RSA Signature Primitive (RSASP1)
 *
 * @param privateKey - An object containing RSA private key components.
 * @param m - The message representative.
 * @returns The signature representative.
 */
declare function RSASP1(privateKey: PrivateKey, m: bigint): bigint;
/**
 * Generates an RSA key pair.
 *
 * This function generates an RSA key pair using the given prime numbers `p` and `q`, and the public exponent `e`.
 * Output:
 *
 * @param p - A prime number.
 * @param q - A prime number.
 * @param e - The public exponent.
 * @returns An object containing the public key and the private key.
 */
export declare function keygen(nlen: number, e?: bigint, randFn?: RandFn): {
    publicKey: {
        e: bigint;
        n: bigint;
    };
    privateKey: {
        d: bigint;
        n: bigint;
    };
};
/**
 * improved ES; based on the optimal asymmetric encryption padding
 * @param hash
 * @param mgfHash
 * @param label optional label to be associated with the message
 */
export declare const OAEP: (hash: Hash, mgfHash: VarLenHash, label?: Uint8Array) => KEM;
/**
 * EMSA-PSS: improved EMSA, based on the probabilistic signature scheme
 * @param opts
 * @returns
 */
export declare const PSS: (hash: Hash, mgfHash: VarLenHash, sLen?: number) => Signer;
/**
 * RSAES-PKCS1-v1_5: older Encryption/decryption Scheme (ES) as first standardized in version 1.5 of PKCS #1. Known-vulnerable.
 */
export declare const PKCS1_KEM: KEM;
export declare const PKCS1_SHA1: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA224: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA256: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA384: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA512: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA512_224: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA512_256: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA3_224: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA3_256: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA3_384: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const PKCS1_SHA3_512: {
    verify(publicKey: PublicKey, M: Uint8Array, S: Uint8Array): boolean;
    sign(privateKey: PrivateKey, M: Uint8Array): Uint8Array;
};
export declare const _TEST: {
    RSAEP: typeof RSAEP;
    RSADP: typeof RSADP;
    RSASP1: typeof RSASP1;
};
export {};
//# sourceMappingURL=rsa.d.ts.map